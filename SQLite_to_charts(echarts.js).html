<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>SQLite Chart Viewer with ECharts</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/sql-wasm.js"></script>
  <style>
    #dataTable { max-height: 300px; overflow: auto; border: 1px solid #ccc; margin-top: 10px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 4px; }
    label { margin-right: 10px; }
    #chartSection { margin-top: 20px; }
    #myChart { width: 800px; height: 400px; }
  </style>
</head>
<body>
  <h2>ğŸ“ è¼‰å…¥ SQLite æª”æ¡ˆ</h2>
  <input type="file" id="dbfile" accept=".sqlite,.db"/><br><br>

  <div id="tableSelectContainer" style="display:none;">
    <label>é¸æ“‡ Table:</label>
    <select id="tableSelect"></select>
    <button onclick="loadTable()">è¼‰å…¥è³‡æ–™</button>
  </div>

  <div id="dataTable"></div>

  <div id="chartSection" style="display:none;">
    <h3>ğŸ“Š åœ–è¡¨è¨­å®š</h3>

    <label>åœ–è¡¨é¡å‹:</label>
	<select id="chartType" onchange="updateChartOptions()">
	  <option value="line">Line</option>
	  <option value="bar">Bar</option>
	  <option value="pie">Pie</option>
	  <option value="scatter">Scatter</option>
	</select>

    <label>è¡¨é”æ–¹å¼:</label>
	<select id="displayMode" onchange="updateFieldUI()">
	  <option value="mapping">å°æ‡‰åˆ†æ</option>
	  <option value="category">åˆ†é¡çµ±è¨ˆ</option>
	  <option value="timeline">æ™‚é–“-é¡åˆ¥åˆ†å¸ƒ</option>
	</select>

    <label>Xè»¸æ¬„ä½:</label>
    <select id="xField"></select>

    <label id="yFieldLabel">Yè»¸æ¬„ä½:</label>
    <select id="yField"></select>

    <button onclick="drawChart()">ç¹ªè£½åœ–è¡¨</button><br><br>

    <div id="myChart"></div>
  </div>

  <script>
    let db;
    let rows = [];
    let columns = [];
    let chart = echarts.init(document.getElementById('myChart'));

    document.getElementById('dbfile').addEventListener('change', async (evt) => {
      const file = evt.target.files[0];
      if (!file) return;

      const buf = await file.arrayBuffer();
      const SQL = await initSqlJs({ locateFile: f => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/${f}` });
      db = new SQL.Database(new Uint8Array(buf));

      const res = db.exec("SELECT name FROM sqlite_master WHERE type='table'");
      const tables = res[0]?.values.map(row => row[0]) || [];

      const select = document.getElementById('tableSelect');
      select.innerHTML = '';
      tables.forEach(t => {
        const option = document.createElement('option');
        option.value = option.text = t;
        select.appendChild(option);
      });

      document.getElementById('tableSelectContainer').style.display = 'block';
    });

    function loadTable() {
      const table = document.getElementById('tableSelect').value;
      const res = db.exec(`SELECT * FROM "${table}"`);
      if (res.length === 0) return alert("ç„¡è³‡æ–™");

      columns = res[0].columns;
      rows = res[0].values;

      // é¡¯ç¤ºè¡¨æ ¼
      const tableHTML = [`<table><thead><tr>${columns.map(c => `<th>${c}</th>`).join('')}</tr></thead><tbody>`];
      rows.forEach(row => {
        tableHTML.push(`<tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>`);
      });
      tableHTML.push(`</tbody></table>`);
      document.getElementById('dataTable').innerHTML = tableHTML.join('');

      // è¨­å®š X/Y é¸å–®
      const xSel = document.getElementById('xField');
      const ySel = document.getElementById('yField');
      xSel.innerHTML = ySel.innerHTML = '';
      columns.forEach(col => {
        [xSel, ySel].forEach(sel => {
          const opt = document.createElement('option');
          opt.value = opt.text = col;
          sel.appendChild(opt.cloneNode(true));
        });
      });

      document.getElementById('chartSection').style.display = 'block';
      updateFieldUI();
    }

	function updateFieldUI() {
	  const mode = document.getElementById('displayMode').value;
	  const yField = document.getElementById('yField');
	  const yLabel = document.getElementById('yFieldLabel');
	  const chartType = document.getElementById('chartType').value;

	  if (mode === 'category' || (mode === 'mapping' && chartType === 'pie')) {
		yField.style.display = 'none';
		yLabel.style.display = 'none';
	  } else {
		yField.style.display = 'inline';
		yLabel.style.display = 'inline';
	  }
	}

	function updateChartOptions() {
	  const chartType = document.getElementById('chartType').value;
	  const xField = document.getElementById('xField');
	  const yField = document.getElementById('yField');
	  const yLabel = document.getElementById('yFieldLabel');
	  const displayMode = document.getElementById('displayMode').value;

	  if (chartType === 'pie') {
		xField.style.display = 'inline';
		yField.style.display = 'none';
		yLabel.style.display = 'none';
	  } else {
		xField.style.display = 'inline';
		yField.style.display = (displayMode === 'category') ? 'none' : 'inline';
		yLabel.style.display = (displayMode === 'category') ? 'none' : 'inline';
	  }
	}


	function drawChart() {
	  const type = document.getElementById('chartType').value;
	  const mode = document.getElementById('displayMode').value;

	  if (rows.length === 0) {
		alert("è«‹å…ˆè¼‰å…¥è³‡æ–™");
		return;
	  }

	  if (type === 'pie') {
		drawCategoryChart(type);
		return;
	  }

	  if (mode === 'mapping') {
		drawMappingChart(type);
	  } else if (mode === 'category') {
		drawCategoryChart(type);
	  } else if (mode === 'timeline') {
		if (type !== 'scatter') {
		  alert("æ™‚é–“-é¡åˆ¥åˆ†å¸ƒåƒ…æ”¯æ´æ•£é»åœ–");
		  return;
		}
		drawTimelineChart();
	  }
	}

    function drawMappingChart(type) {
      const xCol = document.getElementById('xField').value;
      const yCol = document.getElementById('yField').value;
      const xIdx = columns.indexOf(xCol);
      const yIdx = columns.indexOf(yCol);

      const xData = rows.map(r => r[xIdx]);
      const yData = rows.map(r => {
        const val = parseFloat(r[yIdx]);
        return isNaN(val) ? 0 : val;
      });

      const option = {
        title: {
          text: `${yCol} vs ${xCol}`
        },
        tooltip: {
          trigger: 'axis'
        },
        toolbox: {
          feature: {
            restore: {},
            saveAsImage: {}
          }
        },
        xAxis: {
          type: 'category',
          name: xCol,
          data: xData,
          boundaryGap: type === 'bar'
        },
        yAxis: {
          type: 'value',
          name: yCol,
          scale: true // Enable y-axis scaling to fit data
        },
        dataZoom: [
          { type: 'inside', xAxisIndex: 0 }, // Zoom via mouse wheel or drag for x-axis
          { type: 'slider', xAxisIndex: 0 }, // X-axis slider
          { type: 'inside', yAxisIndex: 0 }, // Zoom via mouse wheel or drag for y-axis
          { type: 'slider', yAxisIndex: 0 }  // Y-axis slider
        ],
        series: [{
          data: yData,
          type: type,
          smooth: type === 'line',
          itemStyle: {
            color: 'rgba(75,192,192,0.8)'
          },
          showSymbol: true
        }]
      };

      chart.setOption(option);
    }

	function drawTimelineChart() {
	  const xCol = document.getElementById('xField').value;
	  const yCol = document.getElementById('yField').value;
	  const xIdx = columns.indexOf(xCol);
	  const yIdx = columns.indexOf(yCol);

	  // æå–å”¯ä¸€çš„é¡åˆ¥ï¼ˆY è»¸ï¼‰
	  const categories = [...new Set(rows.map(r => r[yIdx]).filter(val => val != null))];
	  if (categories.length === 0) {
		alert("Y è»¸é¡åˆ¥æ•¸æ“šç„¡æ•ˆï¼Œè«‹é¸æ“‡æœ‰æ•ˆçš„é¡åˆ¥æ¬„ä½");
		return;
	  }

	  // æº–å‚™æ•£é»åœ–æ•¸æ“šï¼Œéæ¿¾ç„¡æ•ˆæ•¸æ“š
	  const seriesData = rows
		.map(r => {
		  const time = r[xIdx];
		  const category = r[yIdx];
		  if (time == null || category == null) return null; // éæ¿¾ç„¡æ•ˆæ•¸æ“š
		  const yValue = categories.indexOf(category);
		  return yValue >= 0 ? [time, yValue] : null; // ç¢ºä¿é¡åˆ¥æœ‰æ•ˆ
		})
		.filter(item => item != null);

	  if (seriesData.length === 0) {
		alert("ç„¡æœ‰æ•ˆçš„æ™‚é–“-é¡åˆ¥æ•¸æ“šï¼Œè«‹æª¢æŸ¥æ•¸æ“šå…§å®¹");
		return;
	  }

	  const option = {
		title: {
		  text: `${yCol} éš¨æ™‚é–“åˆ†å¸ƒ`
		},
		tooltip: {
		  trigger: 'item',
		  formatter: params => {
			if (!params.data || !Array.isArray(params.data)) {
			  return 'ç„¡æœ‰æ•ˆæ•¸æ“š';
			}
			const [time, catIdx] = params.data;
			return `æ™‚é–“: ${time}<br>é¡åˆ¥: ${categories[catIdx] || 'æœªçŸ¥'}`;
		  }
		},
		toolbox: {
		  feature: {
			restore: {},
			saveAsImage: {}
		  }
		},
		xAxis: {
		  type: 'category', // å¦‚æœæ™‚é–“æ˜¯å­—ç¬¦ä¸²æ ¼å¼ï¼Œä½¿ç”¨ category
		  // type: 'time', // å¦‚æœæ™‚é–“æ˜¯æ—¥æœŸæ ¼å¼ï¼Œå¯ä½¿ç”¨ time
		  name: xCol,
		  data: [...new Set(rows.map(r => r[xIdx]).filter(val => val != null))], // éæ¿¾ç„¡æ•ˆæ™‚é–“
		  axisLabel: {
			rotate: 45 // æ—‹è½‰æ¨™ç±¤ä»¥é¿å…é‡ç–Š
		  }
		},
		yAxis: {
		  type: 'category',
		  name: yCol,
		  data: categories // Y è»¸é¡¯ç¤ºé¡åˆ¥åç¨±
		},
		dataZoom: [
		  { type: 'inside', xAxisIndex: 0 }, // X è»¸å…§éƒ¨ç¸®æ”¾
		  { type: 'slider', xAxisIndex: 0 }, // X è»¸æ»‘å¡Š
		  { type: 'inside', yAxisIndex: 0 }, // Y è»¸å…§éƒ¨ç¸®æ”¾
		  { type: 'slider', yAxisIndex: 0 }  // Y è»¸æ»‘å¡Š
		],
		series: [{
		  type: 'scatter',
		  data: seriesData,
		  symbolSize: 10,
		  itemStyle: {
			color: 'rgba(75,192,192,0.8)'
		  }
		}]
	  };

	  chart.setOption(option);
	}

    function drawCategoryChart(type) {
      const xCol = document.getElementById('xField').value;
      const xIdx = columns.indexOf(xCol);

      // çµ±è¨ˆé »ç‡
      const freqMap = {};
      rows.forEach(r => {
        const val = r[xIdx];
        freqMap[val] = (freqMap[val] || 0) + 1;
      });

      const labels = Object.keys(freqMap);
      const data = Object.values(freqMap);

      if (type === 'pie') {
        chart.setOption({
          title: {
            text: `${xCol} é »ç‡çµ±è¨ˆ`
          },
          tooltip: {
            trigger: 'item'
          },
          legend: {
            orient: 'vertical',
            left: 'left',
            data: labels
          },
          series: [{
            name: 'é »ç‡',
            type: 'pie',
            radius: '50%',
            data: labels.map((label, idx) => ({ value: data[idx], name: label })),
            emphasis: {
              itemStyle: {
                shadowBlur: 10,
                shadowOffsetX: 0,
                shadowColor: 'rgba(0,0,0,0.5)'
              }
            }
          }]
        });
      } else {
        chart.setOption({
          title: {
            text: `${xCol} é »ç‡çµ±è¨ˆ`
          },
          tooltip: {
            trigger: 'axis'
          },
          toolbox: {
            feature: {
              restore: {},
              saveAsImage: {}
            }
          },
          xAxis: {
            type: 'category',
            name: xCol,
            data: labels,
            boundaryGap: type === 'bar'
          },
          yAxis: {
            type: 'value',
            name: 'å‡ºç¾æ¬¡æ•¸',
            scale: true // Enable y-axis scaling to fit data
          },
          dataZoom: [
            { type: 'inside', xAxisIndex: 0 }, // Zoom via mouse wheel or drag for x-axis
            { type: 'slider', xAxisIndex: 0 }, // X-axis slider
            { type: 'inside', yAxisIndex: 0 }, // Zoom via mouse wheel or drag for y-axis
            { type: 'slider', yAxisIndex: 0 }  // Y-axis slider
          ],
          series: [{
            data: data,
            type: type,
            itemStyle: {
              color: 'rgba(75,192,192,0.8)'
            },
            smooth: type === 'line'
          }]
        });
      }
    }
  </script>
</body>
</html>
