<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>TSV / Excel åœ–è¡¨ç”¢ç”Ÿå™¨</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5"></script>
  <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background: #f8f9fa;
      padding: 20px;
    }

    .card {
      background: white;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      padding: 20px;
      margin-bottom: 20px;
    }

    textarea {
      width: 100%;
      height: 200px;
      resize: horizontal;
      white-space: pre;
      overflow: auto;
      font-family: monospace;
    }

    table {
      border-collapse: collapse;
      width: max-content;
      min-width: 100%;
    }

    th, td {
      border: 1px solid #ccc;
      padding: 4px 8px;
      white-space: nowrap;
    }

    #dataTable {
      overflow: auto;
      max-height: 300px;
      border: 1px solid #ccc;
      margin-top: 10px;
    }

    select, button, input[type="file"] {
      margin: 8px 5px;
      padding: 6px 10px;
      font-size: 14px;
    }

    button {
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background-color: #0056b3;
    }

    #myChart {
      width: 100%;
      height: 450px;
      min-height: 300px;
    }
  </style>
</head>
<body>

  <div class="card">
    <h2>ğŸ“¥ è³‡æ–™ä¾†æº</h2>
    <label>
      <input type="radio" name="inputMode" value="text" checked onchange="toggleInputMode()"> è¼¸å…¥ TSV
    </label>
    <label>
      <input type="radio" name="inputMode" value="excel" onchange="toggleInputMode()"> ä¸Šå‚³ Excel (.xlsx)
    </label>

    <div id="textInputSection">
      <textarea id="tsvInput" placeholder="è²¼ä¸Š TSV å…§å®¹..."></textarea><br>
      <button onclick="parseTSV()">è§£æ TSV</button>
    </div>

    <div id="excelInputSection" style="display:none;">
      <input type="file" id="excelFile" accept=".xlsx" onchange="handleExcelFile(event)">
    </div>
  </div>

  <div class="card" id="dataSection" style="display:none;">
    <h3>ğŸ“Š è³‡æ–™é è¦½</h3>
    <div id="dataTable"></div>
  </div>

  <div class="card" id="chartSection" style="display:none;">
    <h3>ğŸ“ˆ åœ–è¡¨è¨­å®š</h3>
    <label>åœ–è¡¨é¡å‹:</label>
    <select id="chartType" onchange="updateChartOptions()">
      <option value="line">Line</option>
      <option value="bar">Bar</option>
      <option value="pie">Pie</option>
      <option value="scatter">Scatter</option>
    </select>

    <label>è¡¨é”æ–¹å¼:</label>
    <select id="displayMode" onchange="updateFieldUI()">
      <option value="mapping">å°æ‡‰åˆ†æ</option>
      <option value="category">åˆ†é¡çµ±è¨ˆ</option>
      <option value="timeline">æ™‚é–“-é¡åˆ¥åˆ†å¸ƒ</option>
    </select><br>

    <label>Xè»¸æ¬„ä½:</label>
    <select id="xField"></select>

    <label id="yFieldLabel">Yè»¸æ¬„ä½:</label>
    <select id="yField"></select>

    <button onclick="drawChart()">ç¹ªè£½åœ–è¡¨</button><br><br>

    <div id="myChart"></div>
  </div>

  <script>
    let rows = [];
    let columns = [];
    let chart = echarts.init(document.getElementById('myChart'));

    function toggleInputMode() {
      const mode = document.querySelector('input[name="inputMode"]:checked').value;
      document.getElementById('textInputSection').style.display = (mode === 'text') ? 'block' : 'none';
      document.getElementById('excelInputSection').style.display = (mode === 'excel') ? 'block' : 'none';
    }

    function handleExcelFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: "array" });
        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        const json = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        const tsv = json.map(row => row.join('\t')).join('\n');
        document.getElementById('tsvInput').value = tsv;
        parseTSV();
      };
      reader.readAsArrayBuffer(file);
    }

    function parseTSV() {
      const text = document.getElementById('tsvInput').value.trim();
      const lines = text.split('\n').map(l => l.split('\t'));
      if (lines.length < 2) return alert("è«‹è¼¸å…¥æ­£ç¢ºçš„ TSV");

      columns = lines[0];
      rows = lines.slice(1);

      const table = [`<table><thead><tr>${columns.map(c => `<th>${c}</th>`).join('')}</tr></thead><tbody>`];
      rows.forEach(r => {
        table.push(`<tr>${r.map(cell => `<td>${cell}</td>`).join('')}</tr>`);
      });
      table.push(`</tbody></table>`);
      document.getElementById('dataTable').innerHTML = table.join('');
      document.getElementById('dataSection').style.display = 'block';

      const xSel = document.getElementById('xField');
      const ySel = document.getElementById('yField');
      xSel.innerHTML = ySel.innerHTML = '';
      columns.forEach(col => {
        xSel.add(new Option(col, col));
        ySel.add(new Option(col, col));
      });

      document.getElementById('chartSection').style.display = 'block';
      updateFieldUI();
    }

    function updateFieldUI() {
      const mode = document.getElementById('displayMode').value;
      const chartType = document.getElementById('chartType').value;
      const yField = document.getElementById('yField');
      const yFieldLabel = document.getElementById('yFieldLabel');

      if (mode === 'category' || (chartType === 'pie' && mode !== 'timeline')) {
        yField.style.display = 'none';
        yFieldLabel.style.display = 'none';
      } else {
        yField.style.display = 'inline';
        yFieldLabel.style.display = 'inline';
      }
    }

    function updateChartOptions() {
      const chartType = document.getElementById('chartType').value;
      const displayMode = document.getElementById('displayMode').value;
      const yField = document.getElementById('yField');
      const yFieldLabel = document.getElementById('yFieldLabel');

      if (chartType === 'pie') {
        yField.style.display = 'none';
        yFieldLabel.style.display = 'none';
      } else {
        yField.style.display = (displayMode === 'category') ? 'none' : 'inline';
        yFieldLabel.style.display = (displayMode === 'category') ? 'none' : 'inline';
      }
    }

    function drawChart() {
      const type = document.getElementById('chartType').value;
      const mode = document.getElementById('displayMode').value;

      if (rows.length === 0) {
        alert("è«‹å…ˆè¼‰å…¥è³‡æ–™");
        return;
      }

      try {
        if (type === 'pie') {
          drawCategoryChart(type);
        } else if (mode === 'mapping') {
          drawMappingChart(type);
        } else if (mode === 'category') {
          drawCategoryChart(type);
        } else if (mode === 'timeline') {
          if (type !== 'scatter') {
            alert("æ™‚é–“-é¡åˆ¥åˆ†å¸ƒåƒ…æ”¯æ´æ•£é»åœ–");
            return;
          }
          drawTimelineChart();
        }
        chart.resize(); // ä¿è­‰åœ–è¡¨æ»¿ç‰ˆé¡¯ç¤º
      } catch (error) {
        console.error("ç¹ªè£½åœ–è¡¨æ™‚ç™¼ç”ŸéŒ¯èª¤:", error);
        alert("ç¹ªè£½åœ–è¡¨å¤±æ•—ï¼Œè«‹æª¢æŸ¥æ•¸æ“šæˆ–é¸æ“‡å…¶ä»–è¡¨é”æ–¹å¼");
      }
    }

    function drawMappingChart(type) {
      const xCol = document.getElementById('xField').value;
      const yCol = document.getElementById('yField').value;
      const xIdx = columns.indexOf(xCol);
      const yIdx = columns.indexOf(yCol);

      const xData = rows.map(r => r[xIdx]);
      const yData = rows.map(r => parseFloat(r[yIdx]) || 0);

      chart.setOption({
        title: { text: `${yCol} vs ${xCol}` },
        tooltip: { trigger: 'axis' },
        xAxis: { type: 'category', data: xData },
        yAxis: { type: 'value' },
        series: [{
          type,
          data: type === 'scatter' 
            ? rows.map(r => [parseFloat(r[xIdx]) || 0, parseFloat(r[yIdx]) || 0])
            : yData,
          smooth: type === 'line',
        }],
        dataZoom: [
          { type: 'inside', xAxisIndex: 0 },
          { type: 'slider', xAxisIndex: 0 },
          { type: 'inside', yAxisIndex: 0 },
          { type: 'slider', yAxisIndex: 0 }
        ],
      });
    }

    function drawCategoryChart(type) {
      const xCol = document.getElementById('xField').value;
      const xIdx = columns.indexOf(xCol);
      const counts = {};
      rows.forEach(r => {
        const val = r[xIdx];
        counts[val] = (counts[val] || 0) + 1;
      });
      const labels = Object.keys(counts);
      const values = Object.values(counts);

      if (type === 'pie') {
        chart.setOption({
          title: { text: `${xCol} é »ç‡çµ±è¨ˆ` },
          tooltip: { trigger: 'item' },
          series: [{
            type: 'pie',
            data: labels.map((name, i) => ({ name, value: values[i] }))
          }]
        });
      } else {
        chart.setOption({
          title: { text: `${xCol} é »ç‡çµ±è¨ˆ` },
          tooltip: { trigger: 'axis' },
          xAxis: { type: 'category', data: labels },
          yAxis: { type: 'value' },
          series: [{
            type,
            data: values,
            smooth: type === 'line'
          }],
          dataZoom: [
            { type: 'inside', xAxisIndex: 0 },
            { type: 'slider', xAxisIndex: 0 },
            { type: 'inside', yAxisIndex: 0 },
            { type: 'slider', yAxisIndex: 0 }
          ]
        });
      }
    }

	function drawTimelineChart() {
	  const xCol = document.getElementById('xField').value;
	  const yCol = document.getElementById('yField').value;
	  const xIdx = columns.indexOf(xCol);
	  const yIdx = columns.indexOf(yCol);

	  // æå–å”¯ä¸€çš„é¡åˆ¥ï¼ˆY è»¸ï¼‰
	  const categories = [...new Set(rows.map(r => r[yIdx]).filter(val => val != null))];
	  if (categories.length === 0) {
		alert("Y è»¸é¡åˆ¥æ•¸æ“šç„¡æ•ˆï¼Œè«‹é¸æ“‡æœ‰æ•ˆçš„é¡åˆ¥æ¬„ä½");
		return;
	  }

	  // æº–å‚™æ•£é»åœ–æ•¸æ“šï¼Œéæ¿¾ç„¡æ•ˆæ•¸æ“šä¸¦è½‰æ›æ—¥æœŸæ™‚é–“
	  const seriesData = rows
		.map(r => {
		  const time = r[xIdx];
		  const category = r[yIdx];
		  if (time == null || category == null) return null;
		  const parsedTime = Date.parse(time); // è§£ææ—¥æœŸæ™‚é–“
		  if (isNaN(parsedTime)) return null; // éæ¿¾ç„¡æ•ˆæ—¥æœŸæ™‚é–“
		  const yValue = categories.indexOf(category);
		  return yValue >= 0 ? [parsedTime, yValue] : null;
		})
		.filter(item => item != null);

	  if (seriesData.length === 0) {
		alert("ç„¡æœ‰æ•ˆçš„æ™‚é–“-é¡åˆ¥æ•¸æ“šï¼Œè«‹æª¢æŸ¥æ•¸æ“šå…§å®¹ï¼ˆç¢ºä¿æ™‚é–“æ ¼å¼æ­£ç¢ºï¼Œä¾‹å¦‚ '2023-01-01 14:30:00'ï¼‰");
		return;
	  }

	  // æŒ‰æ™‚é–“æ’åºï¼ˆå¾æœ€æ—©åˆ°æœ€æ™šï¼‰
	  seriesData.sort((a, b) => a[0] - b[0]);

	  const option = {
		title: {
		  text: `${yCol} éš¨æ™‚é–“åˆ†å¸ƒ`
		},
		tooltip: {
		  trigger: 'item',
		  formatter: params => {
			if (!params.data || !Array.isArray(params.data)) {
			  return 'ç„¡æœ‰æ•ˆæ•¸æ“š';
			}
			const [time, catIdx] = params.data;
			const dateTime = new Date(time).toLocaleString('zh-TW', {
			  year: 'numeric',
			  month: '2-digit',
			  day: '2-digit',
			  hour: '2-digit',
			  minute: '2-digit',
			  second: '2-digit'
			}); // æ ¼å¼åŒ–ç‚º "2023/01/01 14:30:00"
			return `æ™‚é–“: ${dateTime}<br>é¡åˆ¥: ${categories[catIdx] || 'æœªçŸ¥'}`;
		  }
		},
		toolbox: {
		  feature: {
			restore: {},
			saveAsImage: {}
		  }
		},
		xAxis: {
		  type: 'time', // ä½¿ç”¨ time é¡å‹ä»¥è™•ç†æ—¥æœŸæ™‚é–“
		  name: xCol,
		  axisLabel: {
			rotate: 45, // æ—‹è½‰æ¨™ç±¤ä»¥é¿å…é‡ç–Š
			formatter: value => {
			  return new Date(value).toLocaleString('zh-TW', {
				year: 'numeric',
				month: '2-digit',
				day: '2-digit',
				hour: '2-digit',
				minute: '2-digit'
			  }); // é¡¯ç¤º "2023/01/01 14:30"
			}
		  }
		},
		yAxis: {
		  type: 'category',
		  name: yCol,
		  data: categories // Y è»¸é¡¯ç¤ºé¡åˆ¥åç¨±
		},
		dataZoom: [
		  { type: 'inside', xAxisIndex: 0 }, // X è»¸å…§éƒ¨ç¸®æ”¾
		  { type: 'slider', xAxisIndex: 0 }, // X è»¸æ»‘å¡Š
		  { type: 'inside', yAxisIndex: 0 }, // Y è»¸å…§éƒ¨ç¸®æ”¾
		  { type: 'slider', yAxisIndex: 0 }  // Y è»¸æ»‘å¡Š
		],
		series: [{
		  type: 'scatter',
		  data: seriesData,
		  symbolSize: 10,
		  itemStyle: {
			color: 'rgba(75,192,192,0.8)'
		  }
		}]
	  };

	  chart.setOption(option);
	}
	function drawTimelineChart() {
	  const xCol = document.getElementById('xField').value;
	  const yCol = document.getElementById('yField').value;
	  const xIdx = columns.indexOf(xCol);
	  const yIdx = columns.indexOf(yCol);

	  // æå–å”¯ä¸€çš„é¡åˆ¥ï¼ˆY è»¸ï¼‰
	  const categories = [...new Set(rows.map(r => r[yIdx]).filter(val => val != null))];
	  if (categories.length === 0) {
		alert("Y è»¸é¡åˆ¥æ•¸æ“šç„¡æ•ˆï¼Œè«‹é¸æ“‡æœ‰æ•ˆçš„é¡åˆ¥æ¬„ä½");
		return;
	  }

	  // æº–å‚™æ•£é»åœ–æ•¸æ“šï¼Œéæ¿¾ç„¡æ•ˆæ•¸æ“šä¸¦è½‰æ›æ—¥æœŸæ™‚é–“
	  const seriesData = rows
		.map(r => {
		  const time = r[xIdx];
		  const category = r[yIdx];
		  if (time == null || category == null) return null;
		  const parsedTime = Date.parse(time); // è§£ææ—¥æœŸæ™‚é–“
		  if (isNaN(parsedTime)) return null; // éæ¿¾ç„¡æ•ˆæ—¥æœŸæ™‚é–“
		  const yValue = categories.indexOf(category);
		  return yValue >= 0 ? [parsedTime, yValue] : null;
		})
		.filter(item => item != null);

	  if (seriesData.length === 0) {
		alert("ç„¡æœ‰æ•ˆçš„æ™‚é–“-é¡åˆ¥æ•¸æ“šï¼Œè«‹æª¢æŸ¥æ•¸æ“šå…§å®¹ï¼ˆç¢ºä¿æ™‚é–“æ ¼å¼æ­£ç¢ºï¼Œä¾‹å¦‚ '2023-01-01 14:30:00'ï¼‰");
		return;
	  }

	  // æŒ‰æ™‚é–“æ’åºï¼ˆå¾æœ€æ—©åˆ°æœ€æ™šï¼‰
	  seriesData.sort((a, b) => a[0] - b[0]);

	  const option = {
		title: {
		  text: `${yCol} éš¨æ™‚é–“åˆ†å¸ƒ`
		},
		tooltip: {
		  trigger: 'item',
		  formatter: params => {
			if (!params.data || !Array.isArray(params.data)) {
			  return 'ç„¡æœ‰æ•ˆæ•¸æ“š';
			}
			const [time, catIdx] = params.data;
			const dateTime = new Date(time).toLocaleString('zh-TW', {
			  year: 'numeric',
			  month: '2-digit',
			  day: '2-digit',
			  hour: '2-digit',
			  minute: '2-digit',
			  second: '2-digit'
			}); // æ ¼å¼åŒ–ç‚º "2023/01/01 14:30:00"
			return `æ™‚é–“: ${dateTime}<br>é¡åˆ¥: ${categories[catIdx] || 'æœªçŸ¥'}`;
		  }
		},
		toolbox: {
		  feature: {
			restore: {},
			saveAsImage: {}
		  }
		},
		xAxis: {
		  type: 'time', // ä½¿ç”¨ time é¡å‹ä»¥è™•ç†æ—¥æœŸæ™‚é–“
		  name: xCol,
		  axisLabel: {
			rotate: 45, // æ—‹è½‰æ¨™ç±¤ä»¥é¿å…é‡ç–Š
			formatter: value => {
			  return new Date(value).toLocaleString('zh-TW', {
				year: 'numeric',
				month: '2-digit',
				day: '2-digit',
				hour: '2-digit',
				minute: '2-digit'
			  }); // é¡¯ç¤º "2023/01/01 14:30"
			}
		  }
		},
		yAxis: {
		  type: 'category',
		  name: yCol,
		  data: categories // Y è»¸é¡¯ç¤ºé¡åˆ¥åç¨±
		},
		dataZoom: [
		  { type: 'inside', xAxisIndex: 0 }, // X è»¸å…§éƒ¨ç¸®æ”¾
		  { type: 'slider', xAxisIndex: 0 }, // X è»¸æ»‘å¡Š
		  { type: 'inside', yAxisIndex: 0 }, // Y è»¸å…§éƒ¨ç¸®æ”¾
		  { type: 'slider', yAxisIndex: 0 }  // Y è»¸æ»‘å¡Š
		],
		series: [{
		  type: 'scatter',
		  data: seriesData,
		  symbolSize: 10,
		  itemStyle: {
			color: 'rgba(75,192,192,0.8)'
		  }
		}]
	  };

	  chart.setOption(option);
	}

    window.addEventListener('resize', () => {
      chart.resize();
    });
  </script>
</body>
</html>
