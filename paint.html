<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ–åƒè™•ç†å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #3b82f6, #a855f7);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 0;
            min-height: 600px;
        }

        .sidebar {
            background: #f8fafc;
            padding: 20px;
            border-right: 1px solid #e2e8f0;
        }

        .tool-section {
            margin-bottom: 25px;
        }

        .tool-section h3 {
            color: #374151;
            font-size: 1rem;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e5e7eb;
        }

        .btn {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            margin: 5px 0;
            width: 100%;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(59, 130, 246, 0.4);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .btn.active {
            background: linear-gradient(135deg, #10b981, #059669);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3);
        }

        .btn.active:hover {
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.4), 0 5px 15px rgba(16, 185, 129, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6b7280, #4b5563);
        }

        .btn-secondary:hover {
            box-shadow: 0 5px 15px rgba(107, 114, 128, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .btn-danger:hover {
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.4);
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #374151;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .color-picker {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-picker input[type="color"] {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .canvas-container {
            position: relative;
            background: #f1f5f9;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 600px;
        }

        #canvas {
            border: 2px dashed #cbd5e1;
            border-radius: 10px;
            background: white;
            cursor: crosshair;
        }

        .drop-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #64748b;
            pointer-events: none;
            z-index: 1;
        }

        .drop-zone.active {
            color: #3b82f6;
            font-weight: bold;
        }

        .status-bar {
            background: #f8fafc;
            padding: 15px 20px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: #64748b;
        }

        .status-info {
            display: flex;
            gap: 20px;
        }

        .loading {
            display: none;
            color: #3b82f6;
            font-weight: 500;
        }

        .loading.show {
            display: inline;
        }

        .tool-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .tool-btn {
            padding: 8px 12px;
            font-size: 0.8rem;
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #10b981, #059669);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3);
        }

        .tool-btn.active:hover {
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.4), 0 5px 15px rgba(16, 185, 129, 0.4);
        }

        .brush-sizes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-bottom: 15px;
        }

        .brush-size {
            padding: 8px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.3s ease;
        }

        .brush-size.active {
            border-color: #3b82f6;
            background: #dbeafe;
            color: #1d4ed8;
        }

        .export-options {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .export-options h4 {
            color: #92400e;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .size-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .size-inputs input {
            padding: 6px 8px;
            font-size: 0.8rem;
        }

        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .export-btn {
            padding: 8px 12px;
            font-size: 0.8rem;
        }

        .export-btn.svg {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .export-btn.png {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        .export-btn.jpg {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .tool-tips {
            background: #ecfdf5;
            border: 1px solid #10b981;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.8rem;
            color: #065f46;
        }

        .tool-tips h4 {
            margin-bottom: 8px;
            color: #047857;
        }

        .tool-tips ul {
            list-style: none;
            padding-left: 0;
        }

        .tool-tips li {
            margin-bottom: 4px;
            padding-left: 15px;
            position: relative;
        }

        .tool-tips li:before {
            content: "â€¢";
            position: absolute;
            left: 0;
            color: #10b981;
        }

        .bg-method-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .color-picker-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .color-picker-modal.show {
            display: flex;
        }

        .color-picker-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 300px;
            width: 90%;
        }

        .color-picker-content h3 {
            margin-bottom: 15px;
            color: #374151;
        }

        .color-picker-content input[type="color"] {
            width: 100px;
            height: 100px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 15px;
        }

        .color-picker-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .api-info {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.8rem;
            color: #92400e;
        }

        .api-info h4 {
            margin-bottom: 8px;
            color: #92400e;
        }

        .api-info ul {
            list-style: none;
            padding-left: 0;
            margin-bottom: 10px;
        }

        .api-info li {
            margin-bottom: 4px;
            padding-left: 15px;
            position: relative;
        }

        .api-info li:before {
            content: "â€¢";
            position: absolute;
            left: 0;
            color: #f59e0b;
        }

        .api-info a {
            color: #d97706;
            text-decoration: none;
        }

        .api-info a:hover {
            text-decoration: underline;
        }

        .unit-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .preset-sizes {
            margin-bottom: 15px;
        }

        .preset-sizes label {
            display: block;
            margin-bottom: 8px;
            color: #374151;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }

        .preset-btn {
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
        }

        .preset-btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .preset-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .export-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .export-btn.webp {
            background: linear-gradient(135deg, #059669, #047857);
        }

        .export-btn.pdf {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
        }

        .settings-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
        }

        .settings-buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .settings-info {
            text-align: center;
            color: #6b7280;
            font-size: 0.75rem;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ åœ–åƒè™•ç†å·¥å…·</h1>
            <p>è¤‡è£½è²¼ä¸Š â€¢ ç¹ªè£½ â€¢ å»èƒŒæ™¯ â€¢ åŒ¯å‡ºå¤šæ ¼å¼</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="tool-tips">
                    <h4>ğŸ’¡ ä½¿ç”¨æç¤º</h4>
                    <ul>
                        <li>æŒ‰ Ctrl+V è²¼ä¸Šåœ–åƒ</li>
                        <li>æ‹–æ‹½åœ–åƒåˆ°ç•«å¸ƒ</li>
                        <li>é»æ“Šç•«å¸ƒé–‹å§‹ç¹ªè£½</li>
                        <li>é¸æ“‡å·¥å…·å’Œé¡è‰²</li>
                    </ul>
                </div>

                <div class="api-info" id="apiInfo" style="display: none;">
                    <h4>ğŸ¤– AI å»èƒŒæ™¯æœå‹™</h4>
                    <ul>
                        <li><strong>Remove.bg:</strong> å°ˆæ¥­å»èƒŒæ™¯ï¼Œæ¯æœˆå…è²»é¡åº¦</li>
                        <li><strong>ClipDrop:</strong> é«˜å“è³ª AI è™•ç†</li>
                        <li><strong>Replicate:</strong> é–‹æºæ¨¡å‹ï¼Œéˆæ´»é…ç½®</li>
                    </ul>
                    <p>éœ€è¦ API Keyï¼Ÿ<a href="#" onclick="showApiHelp()">æŸ¥çœ‹èªªæ˜</a></p>
                </div>

                <div class="tool-section">
                    <h3>ğŸ“‹ åœ–åƒæ“ä½œ</h3>
                    <button class="btn" onclick="pasteImage()">è²¼ä¸Šåœ–åƒ (Ctrl+V)</button>
                    <button class="btn btn-secondary" onclick="clearCanvas()">æ¸…é™¤ç•«å¸ƒ</button>
                    <div class="input-group">
                        <label>å»èƒŒæ™¯æ–¹æ³•</label>
                        <select id="bgMethod" class="bg-method-select">
                            <option value="simple">ç°¡å–®ç§»é™¤ (ç™½è‰²èƒŒæ™¯)</option>
                            <option value="advanced">é€²éšç§»é™¤ (æ™ºèƒ½æª¢æ¸¬)</option>
                            <option value="manual">æ‰‹å‹•é¸æ“‡é¡è‰²</option>
                            <option value="remove-bg">Remove.bg AI</option>
                            <option value="clipdrop">ClipDrop AI</option>
                            <option value="replicate">Replicate AI</option>
                        </select>
                    </div>
                    <div class="input-group" id="apiKeyGroup" style="display: none;">
                        <label>API Key</label>
                        <input type="password" id="apiKey" placeholder="è¼¸å…¥æ‚¨çš„ API Key">
                    </div>
                    <button class="btn btn-danger" onclick="removeBackground()">å»èƒŒæ™¯</button>
                </div>

                <div class="tool-section">
                    <h3>ğŸ¨ ç¹ªè£½å·¥å…·</h3>
                    <div class="input-group">
                        <label>å·¥å…·é¸æ“‡</label>
                        <div class="tool-buttons">
                            <button class="btn tool-btn active" data-tool="brush" onclick="selectTool('brush')">ğŸ–Œï¸ ç•«ç­†</button>
                            <button class="btn tool-btn" data-tool="eraser" onclick="selectTool('eraser')">ğŸ§½ æ©¡çš®æ“¦</button>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>ç•«ç­†é¡è‰²</label>
                        <div class="color-picker">
                            <input type="color" id="brushColor" value="#000000">
                            <span id="colorValue">#000000</span>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>å·¥å…·å¤§å°</label>
                        <div class="brush-sizes">
                            <div class="brush-size active" data-size="2">ç´°</div>
                            <div class="brush-size" data-size="5">ä¸­</div>
                            <div class="brush-size" data-size="10">ç²—</div>
                        </div>
                    </div>

                    <button class="btn" id="drawingBtn" onclick="toggleDrawing()">é–‹å§‹ç¹ªè£½</button>
                </div>

                <div class="export-options">
                    <h4>ğŸ“¤ åŒ¯å‡ºè¨­å®š</h4>
                    
                    <div class="input-group">
                        <label>å°ºå¯¸å–®ä½</label>
                        <select id="exportUnit" class="unit-select">
                            <option value="px">åƒç´  (px)</option>
                            <option value="cm">å…¬åˆ† (cm)</option>
                            <option value="mm">æ¯«ç±³ (mm)</option>
                            <option value="in">è‹±å‹ (in)</option>
                            <option value="pt">é» (pt)</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label>è§£æåº¦ (DPI)</label>
                        <input type="number" id="exportDPI" value="300" min="72" max="600" step="1">
                    </div>
                    
                    <div class="size-inputs">
                        <div class="input-group">
                            <label>å¯¬åº¦</label>
                            <input type="number" id="exportWidth" value="800" min="1" max="10000" step="1">
                        </div>
                        <div class="input-group">
                            <label>é«˜åº¦</label>
                            <input type="number" id="exportHeight" value="600" min="1" max="10000" step="1">
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>ä¿æŒæ¯”ä¾‹</label>
                        <input type="checkbox" id="keepAspectRatio" checked>
                    </div>
                    
                    <div class="preset-sizes">
                        <label>é è¨­å°ºå¯¸</label>
                        <div class="preset-buttons">
                            <button class="preset-btn" data-width="1920" data-height="1080">HD</button>
                            <button class="preset-btn" data-width="2560" data-height="1440">2K</button>
                            <button class="preset-btn" data-width="3840" data-height="2160">4K</button>
                            <button class="preset-btn" data-width="800" data-height="600">ç¶²é </button>
                            <button class="preset-btn" data-width="1080" data-height="1080">æ–¹å½¢</button>
                            <button class="preset-btn" data-width="64" data-height="64">å°åœ–ç¤º</button>
                            <button class="preset-btn" data-width="32" data-height="32">å¾®åœ–ç¤º</button>
                            <button class="preset-btn" data-width="16" data-height="16">æ¥µå°</button>
                        </div>
                    </div>
                    
                    <div class="export-buttons">
                        <button class="btn export-btn svg" onclick="exportImage('svg')">SVG</button>
                        <button class="btn export-btn png" onclick="exportImage('png')">PNG</button>
                        <button class="btn export-btn jpg" onclick="exportImage('jpg')">JPG</button>
                        <button class="btn export-btn webp" onclick="exportImage('webp')">WebP</button>
                        <button class="btn export-btn pdf" onclick="exportImage('pdf')">PDF</button>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>âš™ï¸ è¨­å®šç®¡ç†</h3>
                    <div class="settings-buttons">
                        <button class="btn btn-secondary" onclick="saveSettings('manual')">ğŸ’¾ å„²å­˜è¨­å®š</button>
                        <button class="btn btn-secondary" onclick="loadSettings()">ğŸ“‚ è¼‰å…¥è¨­å®š</button>
                        <button class="btn btn-danger" onclick="resetSettings()">ğŸ”„ é‡ç½®è¨­å®š</button>
                    </div>
                    <div class="settings-info">
                        <small>âœ… è‡ªå‹•å„²å­˜å·²å•Ÿç”¨ - è¨­å®šæœƒè‡ªå‹•å„²å­˜åˆ°ç€è¦½å™¨æœ¬åœ°</small>
                        <br>
                        <small>ğŸ”„ æ¯5åˆ†é˜è‡ªå‹•å‚™ä»½ | ğŸ“ è®Šæ›´å¾Œ2ç§’è‡ªå‹•å„²å­˜</small>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="canvas" width="800" height="600"></canvas>
                <div class="drop-zone" id="dropZone">
                    <h3>æ‹–æ‹½åœ–åƒåˆ°é€™è£¡</h3>
                    <p>æˆ–æŒ‰ Ctrl+V è²¼ä¸Šåœ–åƒ</p>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-info">
                <span id="canvasSize">ç•«å¸ƒ: 800 x 600</span>
                <span id="drawingStatus">ç¹ªè£½æ¨¡å¼: é—œé–‰</span>
            </div>
            <div class="loading" id="loading">è™•ç†ä¸­...</div>
        </div>
    </div>

    <!-- é¡è‰²é¸æ“‡å™¨æ¨¡æ…‹æ¡† -->
    <div class="color-picker-modal" id="colorPickerModal">
        <div class="color-picker-content">
            <h3>é¸æ“‡è¦ç§»é™¤çš„èƒŒæ™¯é¡è‰²</h3>
            <input type="color" id="bgColorPicker" value="#ffffff">
            <div class="color-picker-buttons">
                <button class="btn" onclick="confirmBgColor()">ç¢ºèªç§»é™¤</button>
                <button class="btn btn-secondary" onclick="closeColorPicker()">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- API èªªæ˜æ¨¡æ…‹æ¡† -->
    <div class="color-picker-modal" id="apiHelpModal">
        <div class="color-picker-content" style="max-width: 500px;">
            <h3>ğŸ¤– AI å»èƒŒæ™¯ API è¨­å®š</h3>
            <div style="text-align: left; margin-bottom: 20px;">
                <h4>Remove.bg API</h4>
                <p>1. å‰å¾€ <a href="https://www.remove.bg/api" target="_blank">remove.bg/api</a></p>
                <p>2. è¨»å†Šå¸³è™Ÿä¸¦ç²å– API Key</p>
                <p>3. æ¯æœˆæœ‰å…è²»é¡åº¦</p>
                
                <h4>ClipDrop API</h4>
                <p>1. å‰å¾€ <a href="https://clipdrop.co/api" target="_blank">clipdrop.co/api</a></p>
                <p>2. è¨»å†Šé–‹ç™¼è€…å¸³è™Ÿ</p>
                <p>3. ç²å– API Key</p>
                
                <h4>Replicate API</h4>
                <p>1. å‰å¾€ <a href="https://replicate.com" target="_blank">replicate.com</a></p>
                <p>2. è¨»å†Šå¸³è™Ÿä¸¦ç²å– API Token</p>
                <p>3. æ”¯æ´å¤šç¨®é–‹æºæ¨¡å‹</p>
            </div>
            <button class="btn" onclick="closeApiHelp()">äº†è§£</button>
        </div>
    </div>

    <script>
        // ç²å–ç•«å¸ƒå’Œä¸Šä¸‹æ–‡
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // ç‹€æ…‹è®Šæ•¸
        let isDrawing = false;
        let isDrawingMode = false;
        let lastX = 0;
        let lastY = 0;
        let brushSize = 5;
        let brushColor = '#000000';
        let currentTool = 'brush';
        let hasImage = false;

        // åˆå§‹åŒ–
        function init() {
            setupEventListeners();
            updateStatus();
            setupColorPicker();
            setupBrushSizes();
        }

        // è¨­ç½®äº‹ä»¶ç›£è½å™¨
        function setupEventListeners() {
            // éµç›¤äº‹ä»¶
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'v') {
                    e.preventDefault();
                    pasteImage();
                }
            });

            // ç•«å¸ƒäº‹ä»¶
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            // æ‹–æ‹½äº‹ä»¶
            canvas.addEventListener('dragover', handleDragOver);
            canvas.addEventListener('drop', handleDrop);

            // é»æ“Šç•«å¸ƒå€åŸŸ
            document.querySelector('.canvas-container').addEventListener('click', () => {
                canvas.focus();
            });

            // å»èƒŒæ™¯æ–¹æ³•é¸æ“‡äº‹ä»¶
            document.getElementById('bgMethod').addEventListener('change', updateApiKeyVisibility);
            
            // åŒ¯å‡ºè¨­å®šäº‹ä»¶
            setupExportEvents();
            
            // è¨­å®šè‡ªå‹•å„²å­˜
            setupAutoSave();
        }

        // è¨­ç½®é¡è‰²é¸æ“‡å™¨
        function setupColorPicker() {
            const colorPicker = document.getElementById('brushColor');
            const colorValue = document.getElementById('colorValue');
            
            colorPicker.addEventListener('input', (e) => {
                brushColor = e.target.value;
                colorValue.textContent = brushColor;
                // æ›´æ–°æ¸¸æ¨™é¡è‰²
                if (isDrawingMode && currentTool === 'brush') {
                    updateCursor();
                }
            });
        }

        // è¨­ç½®ç•«ç­†å¤§å°
        function setupBrushSizes() {
            const brushSizes = document.querySelectorAll('.brush-size');
            
            brushSizes.forEach(btn => {
                btn.addEventListener('click', () => {
                    brushSizes.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    brushSize = parseInt(btn.dataset.size);
                });
            });
        }

        // é–‹å§‹ç¹ªè£½
        function startDrawing(e) {
            if (!isDrawingMode) return;
            
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
        }

        // ç¹ªè£½
        function draw(e) {
            if (!isDrawing || !isDrawingMode) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            
            if (currentTool === 'eraser') {
                ctx.strokeStyle = '#ffffff';
                ctx.globalCompositeOperation = 'destination-out';
            } else {
                ctx.strokeStyle = brushColor;
                ctx.globalCompositeOperation = 'source-over';
            }
            
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';
            ctx.stroke();

            lastX = x;
            lastY = y;
        }

        // åœæ­¢ç¹ªè£½
        function stopDrawing() {
            isDrawing = false;
        }

        // é¸æ“‡å·¥å…·
        function selectTool(tool) {
            currentTool = tool;
            
            // æ›´æ–°å·¥å…·æŒ‰éˆ•ç‹€æ…‹
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            
            // æ›´æ–°æ¸¸æ¨™
            if (isDrawingMode) {
                updateCursor();
            }
        }

        // åˆ‡æ›ç¹ªè£½æ¨¡å¼
        function toggleDrawing() {
            isDrawingMode = !isDrawingMode;
            updateStatus();
            updateCursor();
            updateDrawingButton();
        }

        // æ›´æ–°æ¸¸æ¨™
        function updateCursor() {
            if (isDrawingMode) {
                if (currentTool === 'eraser') {
                    // æ©¡çš®æ“¦æ¸¸æ¨™
                    const eraserCursor = `url("data:image/svg+xml;base64,${btoa(`
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="12" cy="12" r="10" fill="white" stroke="#666" stroke-width="2"/>
                            <path d="M8 8L16 16M16 8L8 16" stroke="#666" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    `)}") 12 12, auto`;
                    canvas.style.cursor = eraserCursor;
                } else {
                    // ç•«ç­†æ¸¸æ¨™
                    const brushCursor = `url("data:image/svg+xml;base64,${btoa(`
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M3 21L12 12L21 3L18 0L9 9L0 18L3 21Z" fill="${brushColor}" stroke="#333" stroke-width="1"/>
                            <circle cx="12" cy="12" r="2" fill="${brushColor}"/>
                        </svg>
                    `)}") 12 12, auto`;
                    canvas.style.cursor = brushCursor;
                }
            } else {
                canvas.style.cursor = 'default';
            }
        }

        // æ›´æ–°ç¹ªè£½æŒ‰éˆ•
        function updateDrawingButton() {
            const btn = document.getElementById('drawingBtn');
            if (isDrawingMode) {
                btn.textContent = 'åœæ­¢ç¹ªè£½';
                btn.classList.add('active');
            } else {
                btn.textContent = 'é–‹å§‹ç¹ªè£½';
                btn.classList.remove('active');
            }
        }

        // è²¼ä¸Šåœ–åƒ
        async function pasteImage() {
            try {
                const clipboardItems = await navigator.clipboard.read();
                for (const clipboardItem of clipboardItems) {
                    for (const type of clipboardItem.types) {
                        if (type.startsWith('image/')) {
                            const blob = await clipboardItem.getType(type);
                            loadImageFromBlob(blob);
                            return;
                        }
                    }
                }
                alert('å‰ªè²¼ç°¿ä¸­æ²’æœ‰æ‰¾åˆ°åœ–åƒ');
            } catch (error) {
                console.error('è²¼ä¸Šå¤±æ•—:', error);
                alert('è²¼ä¸Šå¤±æ•—ï¼Œè«‹ç¢ºä¿å‰ªè²¼ç°¿ä¸­æœ‰åœ–åƒ');
            }
        }

        // å¾ Blob è¼‰å…¥åœ–åƒ
        function loadImageFromBlob(blob) {
            const url = URL.createObjectURL(blob);
            const img = new Image();
            
            img.onload = () => {
                // èª¿æ•´ç•«å¸ƒå¤§å°ä»¥é©æ‡‰åœ–åƒ
                const maxWidth = 800;
                const maxHeight = 600;
                let { width, height } = img;
                
                if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width *= ratio;
                    height *= ratio;
                }
                
                canvas.width = width;
                canvas.height = height;
                
                // ç¹ªè£½åœ–åƒ
                ctx.clearRect(0, 0, width, height);
                ctx.drawImage(img, 0, 0, width, height);
                
                URL.revokeObjectURL(url);
                hasImage = true;
                updateStatus();
                updateDropZone();
            };
            
            img.src = url;
        }

        // è™•ç†æ‹–æ‹½
        function handleDragOver(e) {
            e.preventDefault();
            document.getElementById('dropZone').classList.add('active');
        }

        function handleDrop(e) {
            e.preventDefault();
            document.getElementById('dropZone').classList.remove('active');
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('image/')) {
                loadImageFromBlob(files[0]);
            }
        }

        // æ¸…é™¤ç•«å¸ƒ
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // å»èƒŒæ™¯åŠŸèƒ½
        async function removeBackground() {
            const method = document.getElementById('bgMethod').value;
            
            if (method === 'manual') {
                showColorPicker();
                return;
            }
            
            if (['remove-bg', 'clipdrop', 'replicate'].includes(method)) {
                const apiKey = document.getElementById('apiKey').value.trim();
                if (!apiKey) {
                    alert('è«‹è¼¸å…¥ API Key');
                    return;
                }
                await removeBackgroundWithAI(method, apiKey);
                return;
            }
            
            showLoading(true);
            
            try {
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                if (method === 'simple') {
                    removeColorRange(data, [240, 240, 240], [255, 255, 255], 30);
                } else if (method === 'advanced') {
                    removeAdvancedBackground(data, canvas.width, canvas.height);
                }
                
                ctx.putImageData(imageData, 0, 0);
                alert('èƒŒæ™¯ç§»é™¤å®Œæˆï¼');
            } catch (error) {
                console.error('å»èƒŒæ™¯å¤±æ•—:', error);
                alert('å»èƒŒæ™¯å¤±æ•—');
            } finally {
                showLoading(false);
            }
        }

        // ç§»é™¤æŒ‡å®šé¡è‰²ç¯„åœ
        function removeColorRange(data, minColor, maxColor, tolerance) {
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // æª¢æŸ¥æ˜¯å¦åœ¨æŒ‡å®šé¡è‰²ç¯„åœå…§
                if (r >= minColor[0] - tolerance && r <= maxColor[0] + tolerance &&
                    g >= minColor[1] - tolerance && g <= maxColor[1] + tolerance &&
                    b >= minColor[2] - tolerance && b <= maxColor[2] + tolerance) {
                    data[i + 3] = 0; // è¨­ç‚ºé€æ˜
                }
            }
        }

        // é€²éšèƒŒæ™¯ç§»é™¤ç®—æ³•
        function removeAdvancedBackground(data, width, height) {
            // é‚Šç·£æª¢æ¸¬å’Œé¡è‰²èšé¡
            const edges = detectEdges(data, width, height);
            const backgroundMask = createBackgroundMask(data, width, height);
            
            // çµåˆé‚Šç·£æª¢æ¸¬å’ŒèƒŒæ™¯é®ç½©
            for (let i = 0; i < data.length; i += 4) {
                const pixelIndex = i / 4;
                const x = pixelIndex % width;
                const y = Math.floor(pixelIndex / width);
                
                if (backgroundMask[pixelIndex] && !edges[pixelIndex]) {
                    data[i + 3] = 0; // è¨­ç‚ºé€æ˜
                }
            }
        }

        // é‚Šç·£æª¢æ¸¬
        function detectEdges(data, width, height) {
            const edges = new Array(data.length / 4).fill(false);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // è¨ˆç®—æ¢¯åº¦
                    const gx = Math.abs(data[idx + 4] - data[idx - 4]);
                    const gy = Math.abs(data[idx + width * 4] - data[idx - width * 4]);
                    const gradient = Math.sqrt(gx * gx + gy * gy);
                    
                    if (gradient > 30) {
                        edges[y * width + x] = true;
                    }
                }
            }
            
            return edges;
        }

        // å‰µå»ºèƒŒæ™¯é®ç½©
        function createBackgroundMask(data, width, height) {
            const mask = new Array(data.length / 4).fill(false);
            const visited = new Array(data.length / 4).fill(false);
            
            // å¾é‚Šç·£é–‹å§‹å¡«å……
            const queue = [];
            
            // æ·»åŠ é‚Šç·£åƒç´ 
            for (let x = 0; x < width; x++) {
                queue.push([x, 0]);
                queue.push([x, height - 1]);
            }
            for (let y = 0; y < height; y++) {
                queue.push([0, y]);
                queue.push([width - 1, y]);
            }
            
            // æ´ªæ°´å¡«å……ç®—æ³•
            while (queue.length > 0) {
                const [x, y] = queue.shift();
                const idx = y * width + x;
                
                if (visited[idx]) continue;
                visited[idx] = true;
                
                const pixelIdx = idx * 4;
                const r = data[pixelIdx];
                const g = data[pixelIdx + 1];
                const b = data[pixelIdx + 2];
                
                // æª¢æŸ¥æ˜¯å¦ç‚ºèƒŒæ™¯è‰²
                if (isBackgroundColor(r, g, b)) {
                    mask[idx] = true;
                    
                    // æ·»åŠ ç›¸é„°åƒç´ 
                    const neighbors = [
                        [x + 1, y], [x - 1, y],
                        [x, y + 1], [x, y - 1]
                    ];
                    
                    for (const [nx, ny] of neighbors) {
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            queue.push([nx, ny]);
                        }
                    }
                }
            }
            
            return mask;
        }

        // åˆ¤æ–·æ˜¯å¦ç‚ºèƒŒæ™¯è‰²
        function isBackgroundColor(r, g, b) {
            // æª¢æŸ¥æ˜¯å¦æ¥è¿‘ç™½è‰²æˆ–æ·ºè‰²
            const brightness = (r + g + b) / 3;
            const saturation = Math.max(r, g, b) - Math.min(r, g, b);
            
            return brightness > 200 && saturation < 50;
        }

        // é¡¯ç¤ºé¡è‰²é¸æ“‡å™¨
        function showColorPicker() {
            document.getElementById('colorPickerModal').classList.add('show');
        }

        // é—œé–‰é¡è‰²é¸æ“‡å™¨
        function closeColorPicker() {
            document.getElementById('colorPickerModal').classList.remove('show');
        }

        // ç¢ºèªèƒŒæ™¯é¡è‰²ç§»é™¤
        function confirmBgColor() {
            const color = document.getElementById('bgColorPicker').value;
            const rgb = hexToRgb(color);
            
            showLoading(true);
            
            setTimeout(() => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // ç§»é™¤æŒ‡å®šé¡è‰²
                removeColorRange(data, [rgb.r - 30, rgb.g - 30, rgb.b - 30], 
                                       [rgb.r + 30, rgb.g + 30, rgb.b + 30], 30);
                
                ctx.putImageData(imageData, 0, 0);
                closeColorPicker();
                showLoading(false);
                alert('èƒŒæ™¯é¡è‰²ç§»é™¤å®Œæˆï¼');
            }, 500);
        }

        // åå…­é€²åˆ¶è½‰RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // æ›´æ–° API Key é¡¯ç¤º
        function updateApiKeyVisibility() {
            const method = document.getElementById('bgMethod').value;
            const apiKeyGroup = document.getElementById('apiKeyGroup');
            const apiInfo = document.getElementById('apiInfo');
            
            if (['remove-bg', 'clipdrop', 'replicate'].includes(method)) {
                apiKeyGroup.style.display = 'block';
                apiInfo.style.display = 'block';
            } else {
                apiKeyGroup.style.display = 'none';
                apiInfo.style.display = 'none';
            }
        }

        // AI å»èƒŒæ™¯
        async function removeBackgroundWithAI(method, apiKey) {
            showLoading(true);
            
            try {
                const imageBlob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });
                
                let result;
                
                switch (method) {
                    case 'remove-bg':
                        result = await callRemoveBgAPI(imageBlob, apiKey);
                        break;
                    case 'clipdrop':
                        result = await callClipDropAPI(imageBlob, apiKey);
                        break;
                    case 'replicate':
                        result = await callReplicateAPI(imageBlob, apiKey);
                        break;
                }
                
                if (result) {
                    const img = new Image();
                    img.onload = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        alert('AI å»èƒŒæ™¯å®Œæˆï¼');
                    };
                    img.src = result;
                }
            } catch (error) {
                console.error('AI å»èƒŒæ™¯å¤±æ•—:', error);
                alert('AI å»èƒŒæ™¯å¤±æ•—: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        // Remove.bg API
        async function callRemoveBgAPI(imageBlob, apiKey) {
            const formData = new FormData();
            formData.append('image_file', imageBlob, 'image.png');
            
            const response = await fetch('https://api.remove.bg/v1.0/removebg', {
                method: 'POST',
                headers: {
                    'X-Api-Key': apiKey
                },
                body: formData
            });
            
            if (!response.ok) {
                throw new Error(`Remove.bg API éŒ¯èª¤: ${response.status}`);
            }
            
            const blob = await response.blob();
            return URL.createObjectURL(blob);
        }

        // ClipDrop API
        async function callClipDropAPI(imageBlob, apiKey) {
            const formData = new FormData();
            formData.append('image', imageBlob);
            
            const response = await fetch('https://clipdrop-api.co/remove-background/v1', {
                method: 'POST',
                headers: {
                    'x-api-key': apiKey
                },
                body: formData
            });
            
            if (!response.ok) {
                throw new Error(`ClipDrop API éŒ¯èª¤: ${response.status}`);
            }
            
            const blob = await response.blob();
            return URL.createObjectURL(blob);
        }

        // Replicate API
        async function callReplicateAPI(imageBlob, apiKey) {
            // å°‡åœ–åƒè½‰æ›ç‚º base64
            const base64 = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.readAsDataURL(imageBlob);
            });
            
            const response = await fetch('https://api.replicate.com/v1/predictions', {
                method: 'POST',
                headers: {
                    'Authorization': `Token ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    version: "fb8af171cfa1616ddcf1242c093f9c46bcada5ad4cf6f2fbe8b81b330ec0c003",
                    input: {
                        image: `data:image/png;base64,${base64}`
                    }
                })
            });
            
            if (!response.ok) {
                throw new Error(`Replicate API éŒ¯èª¤: ${response.status}`);
            }
            
            const prediction = await response.json();
            
            // è¼ªè©¢çµæœ
            let result;
            for (let i = 0; i < 30; i++) {
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                const statusResponse = await fetch(prediction.urls.get, {
                    headers: {
                        'Authorization': `Token ${apiKey}`
                    }
                });
                
                const status = await statusResponse.json();
                
                if (status.status === 'succeeded') {
                    result = status.output;
                    break;
                } else if (status.status === 'failed') {
                    throw new Error('Replicate è™•ç†å¤±æ•—');
                }
            }
            
            if (!result) {
                throw new Error('Replicate è™•ç†è¶…æ™‚');
            }
            
            return result;
        }

        // é¡¯ç¤º API èªªæ˜
        function showApiHelp() {
            document.getElementById('apiHelpModal').classList.add('show');
        }

        // é—œé–‰ API èªªæ˜
        function closeApiHelp() {
            document.getElementById('apiHelpModal').classList.remove('show');
        }

        // è¨­å®šç®¡ç†åŠŸèƒ½
        function saveSettings() {
            const settings = {
                // ç¹ªè£½å·¥å…·è¨­å®š
                brushColor: brushColor,
                brushSize: brushSize,
                currentTool: currentTool,
                
                // åŒ¯å‡ºè¨­å®š
                exportUnit: document.getElementById('exportUnit').value,
                exportDPI: document.getElementById('exportDPI').value,
                exportWidth: document.getElementById('exportWidth').value,
                exportHeight: document.getElementById('exportHeight').value,
                keepAspectRatio: document.getElementById('keepAspectRatio').checked,
                
                // å»èƒŒæ™¯è¨­å®š
                bgMethod: document.getElementById('bgMethod').value,
                apiKey: document.getElementById('apiKey').value,
                
                // æ™‚é–“æˆ³è¨˜
                savedAt: new Date().toISOString()
            };
            
            try {
                localStorage.setItem('imageEditorSettings', JSON.stringify(settings));
                // åªåœ¨æ‰‹å‹•å„²å­˜æ™‚é¡¯ç¤ºé€šçŸ¥
                if (arguments.length > 0 && arguments[0] === 'manual') {
                    showNotification('è¨­å®šå·²å„²å­˜ï¼', 'success');
                }
            } catch (error) {
                console.error('å„²å­˜è¨­å®šå¤±æ•—:', error);
                showNotification('å„²å­˜è¨­å®šå¤±æ•—', 'error');
            }
        }

        function loadSettings() {
            const saved = localStorage.getItem('imageEditorSettings');
            if (!saved) return;
            
            try {
                const settings = JSON.parse(saved);
                
                // è¼‰å…¥ç¹ªè£½å·¥å…·è¨­å®š
                if (settings.brushColor) {
                    brushColor = settings.brushColor;
                    document.getElementById('brushColor').value = brushColor;
                    document.getElementById('colorValue').textContent = brushColor;
                }
                
                if (settings.brushSize) {
                    brushSize = settings.brushSize;
                    document.querySelectorAll('.brush-size').forEach(btn => {
                        btn.classList.remove('active');
                        if (parseInt(btn.dataset.size) === brushSize) {
                            btn.classList.add('active');
                        }
                    });
                }
                
                if (settings.currentTool) {
                    currentTool = settings.currentTool;
                    selectTool(currentTool);
                }
                
                // è¼‰å…¥åŒ¯å‡ºè¨­å®š
                if (settings.exportUnit) {
                    document.getElementById('exportUnit').value = settings.exportUnit;
                }
                
                if (settings.exportDPI) {
                    document.getElementById('exportDPI').value = settings.exportDPI;
                }
                
                if (settings.exportWidth) {
                    document.getElementById('exportWidth').value = settings.exportWidth;
                }
                
                if (settings.exportHeight) {
                    document.getElementById('exportHeight').value = settings.exportHeight;
                }
                
                if (settings.keepAspectRatio !== undefined) {
                    document.getElementById('keepAspectRatio').checked = settings.keepAspectRatio;
                }
                
                // è¼‰å…¥å»èƒŒæ™¯è¨­å®š
                if (settings.bgMethod) {
                    document.getElementById('bgMethod').value = settings.bgMethod;
                    updateApiKeyVisibility();
                }
                
                if (settings.apiKey) {
                    document.getElementById('apiKey').value = settings.apiKey;
                }
                
                showNotification('è¨­å®šå·²è¼‰å…¥ï¼', 'success');
                
            } catch (error) {
                console.error('è¼‰å…¥è¨­å®šå¤±æ•—:', error);
                showNotification('è¼‰å…¥è¨­å®šå¤±æ•—', 'error');
            }
        }

        function resetSettings() {
            if (confirm('ç¢ºå®šè¦é‡ç½®æ‰€æœ‰è¨­å®šå—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚')) {
                localStorage.removeItem('imageEditorSettings');
                
                // é‡ç½®ç‚ºé è¨­å€¼
                brushColor = '#000000';
                brushSize = 5;
                currentTool = 'brush';
                
                document.getElementById('brushColor').value = brushColor;
                document.getElementById('colorValue').textContent = brushColor;
                document.getElementById('exportUnit').value = 'px';
                document.getElementById('exportDPI').value = '300';
                document.getElementById('exportWidth').value = '800';
                document.getElementById('exportHeight').value = '600';
                document.getElementById('keepAspectRatio').checked = true;
                document.getElementById('bgMethod').value = 'simple';
                document.getElementById('apiKey').value = '';
                
                // é‡ç½®å·¥å…·é¸æ“‡
                selectTool('brush');
                updateApiKeyVisibility();
                
                showNotification('è¨­å®šå·²é‡ç½®ï¼', 'success');
            }
        }

        // é¡¯ç¤ºé€šçŸ¥
        function showNotification(message, type = 'info') {
            // å‰µå»ºé€šçŸ¥å…ƒç´ 
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                color: white;
                font-size: 0.9rem;
                z-index: 10000;
                animation: slideIn 0.3s ease;
                background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'};
            `;
            
            document.body.appendChild(notification);
            
            // 3ç§’å¾Œè‡ªå‹•ç§»é™¤
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // è‡ªå‹•å„²å­˜è¨­å®š
        function setupAutoSave() {
            let autoSaveTimer = null;
            
            // è‡ªå‹•å„²å­˜å‡½æ•¸
            function triggerAutoSave() {
                if (autoSaveTimer) {
                    clearTimeout(autoSaveTimer);
                }
                autoSaveTimer = setTimeout(() => {
                    saveSettings();
                    autoSaveTimer = null;
                }, 2000); // å»¶é²2ç§’è‡ªå‹•å„²å­˜
            }
            
            // ç›£è½è¨­å®šè®Šæ›´
            const settingsElements = [
                'brushColor', 'exportUnit', 'exportDPI', 'exportWidth', 
                'exportHeight', 'keepAspectRatio', 'bgMethod', 'apiKey'
            ];
            
            settingsElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('change', triggerAutoSave);
                    element.addEventListener('input', triggerAutoSave);
                }
            });
            
            // ç›£è½å·¥å…·é¸æ“‡è®Šæ›´
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', triggerAutoSave);
            });
            
            // ç›£è½ç•«ç­†å¤§å°è®Šæ›´
            document.querySelectorAll('.brush-size').forEach(btn => {
                btn.addEventListener('click', triggerAutoSave);
            });
            
            // ç›£è½é è¨­å°ºå¯¸æŒ‰éˆ•
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', triggerAutoSave);
            });
            
            // é é¢é›¢é–‹å‰è‡ªå‹•å„²å­˜
            window.addEventListener('beforeunload', () => {
                if (autoSaveTimer) {
                    clearTimeout(autoSaveTimer);
                    saveSettings();
                }
            });
            
            // å®šæœŸè‡ªå‹•å„²å­˜ (æ¯5åˆ†é˜)
            setInterval(() => {
                saveSettings();
            }, 5 * 60 * 1000);
        }

        // è¨­ç½®åŒ¯å‡ºäº‹ä»¶
        function setupExportEvents() {
            // é è¨­å°ºå¯¸æŒ‰éˆ•
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const width = parseInt(btn.dataset.width);
                    const height = parseInt(btn.dataset.height);
                    document.getElementById('exportWidth').value = width;
                    document.getElementById('exportHeight').value = height;
                    
                    // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                    document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });
            
            // ä¿æŒæ¯”ä¾‹
            document.getElementById('keepAspectRatio').addEventListener('change', (e) => {
                if (e.target.checked) {
                    setupAspectRatio();
                }
            });
            
            // å°ºå¯¸å–®ä½è®Šæ›´
            document.getElementById('exportUnit').addEventListener('change', updateSizeDisplay);
            
            // å¯¬åº¦è®Šæ›´æ™‚ä¿æŒæ¯”ä¾‹
            document.getElementById('exportWidth').addEventListener('input', (e) => {
                if (document.getElementById('keepAspectRatio').checked) {
                    updateHeightFromWidth(e.target.value);
                }
            });
        }

        // è¨­ç½®é•·å¯¬æ¯”
        function setupAspectRatio() {
            const currentWidth = canvas.width;
            const currentHeight = canvas.height;
            const ratio = currentWidth / currentHeight;
            
            document.getElementById('exportWidth').value = currentWidth;
            document.getElementById('exportHeight').value = currentHeight;
        }

        // æ ¹æ“šå¯¬åº¦æ›´æ–°é«˜åº¦
        function updateHeightFromWidth(width) {
            const currentWidth = canvas.width;
            const currentHeight = canvas.height;
            const ratio = currentWidth / currentHeight;
            
            const newHeight = Math.round(width / ratio);
            document.getElementById('exportHeight').value = newHeight;
        }

        // æ›´æ–°å°ºå¯¸é¡¯ç¤º
        function updateSizeDisplay() {
            const unit = document.getElementById('exportUnit').value;
            const dpi = parseInt(document.getElementById('exportDPI').value);
            
            // é€™è£¡å¯ä»¥æ·»åŠ å–®ä½è½‰æ›é‚è¼¯
            console.log(`å°ºå¯¸å–®ä½: ${unit}, DPI: ${dpi}`);
        }

        // åŒ¯å‡ºåœ–åƒ
        function exportImage(format) {
            const width = parseInt(document.getElementById('exportWidth').value);
            const height = parseInt(document.getElementById('exportHeight').value);
            const dpi = parseInt(document.getElementById('exportDPI').value);
            const unit = document.getElementById('exportUnit').value;
            
            if (width < 1 || height < 1) {
                alert('å°ºå¯¸ä¸èƒ½å°æ–¼ 1');
                return;
            }
            
            // æ ¹æ“šå–®ä½å’ŒDPIè¨ˆç®—å¯¦éš›åƒç´ å°ºå¯¸
            const actualWidth = convertToPixels(width, unit, dpi);
            const actualHeight = convertToPixels(height, unit, dpi);
            
            // å‰µå»ºè‡¨æ™‚ç•«å¸ƒ
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = actualWidth;
            tempCanvas.height = actualHeight;
            
            // ç¸®æ”¾ç¹ªè£½
            tempCtx.drawImage(canvas, 0, 0, actualWidth, actualHeight);
            
            // åŒ¯å‡º
            let dataURL;
            let filename;
            let mimeType;
            
            switch (format) {
                case 'svg':
                    const svgContent = generateSVG();
                    downloadFile(svgContent, 'image.svg', 'image/svg+xml');
                    return;
                case 'png':
                    dataURL = tempCanvas.toDataURL('image/png');
                    filename = 'image.png';
                    mimeType = 'image/png';
                    break;
                case 'jpg':
                    dataURL = tempCanvas.toDataURL('image/jpeg', 0.9);
                    filename = 'image.jpg';
                    mimeType = 'image/jpeg';
                    break;
                case 'webp':
                    dataURL = tempCanvas.toDataURL('image/webp', 0.9);
                    filename = 'image.webp';
                    mimeType = 'image/webp';
                    break;
                case 'pdf':
                    generatePDF(tempCanvas, width, height, unit, dpi);
                    return;
            }
            
            downloadFile(dataURL, filename, mimeType);
        }

        // å–®ä½è½‰æ›ç‚ºåƒç´ 
        function convertToPixels(value, unit, dpi) {
            switch (unit) {
                case 'px':
                    return value;
                case 'cm':
                    return Math.round(value * dpi / 2.54);
                case 'mm':
                    return Math.round(value * dpi / 25.4);
                case 'in':
                    return Math.round(value * dpi);
                case 'pt':
                    return Math.round(value * dpi / 72);
                default:
                    return value;
            }
        }

        // ç”Ÿæˆ PDF
        function generatePDF(canvas, width, height, unit, dpi) {
            // é€™è£¡éœ€è¦å¼•å…¥ PDF ç”Ÿæˆåº«ï¼Œå¦‚ jsPDF
            // æš«æ™‚æä¾›ä¸‹è¼‰ canvas çš„æ–¹å¼
            const dataURL = canvas.toDataURL('image/png');
            downloadFile(dataURL, 'image.pdf', 'application/pdf');
        }

        // ç”Ÿæˆ SVG
        function generateSVG() {
            const width = parseInt(document.getElementById('exportWidth').value);
            const height = parseInt(document.getElementById('exportHeight').value);
            const unit = document.getElementById('exportUnit').value;
            
            // å°‡ç•«å¸ƒè½‰æ›ç‚º base64
            const dataURL = canvas.toDataURL('image/png');
            
            return `<svg width="${width}${unit}" height="${height}${unit}" xmlns="http://www.w3.org/2000/svg">
                <image href="${dataURL}" width="${width}${unit}" height="${height}${unit}"/>
            </svg>`;
        }

        // ä¸‹è¼‰æª”æ¡ˆ
        function downloadFile(content, filename, mimeType = null) {
            const link = document.createElement('a');
            
            if (mimeType) {
                const blob = new Blob([content], { type: mimeType });
                link.href = URL.createObjectURL(blob);
            } else {
                link.href = content;
            }
            
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // æ›´æ–°ç‹€æ…‹
        function updateStatus() {
            document.getElementById('canvasSize').textContent = `ç•«å¸ƒ: ${canvas.width} x ${canvas.height}`;
            document.getElementById('drawingStatus').textContent = `ç¹ªè£½æ¨¡å¼: ${isDrawingMode ? 'é–‹å•Ÿ' : 'é—œé–‰'}`;
        }

        // æ›´æ–°æ‹–æ‹½å€åŸŸé¡¯ç¤º
        function updateDropZone() {
            const dropZone = document.getElementById('dropZone');
            if (hasImage) {
                dropZone.style.display = 'none';
            } else {
                dropZone.style.display = 'block';
            }
        }

        // é¡¯ç¤º/éš±è—è¼‰å…¥ç‹€æ…‹
        function showLoading(show) {
            const loading = document.getElementById('loading');
            if (show) {
                loading.classList.add('show');
            } else {
                loading.classList.remove('show');
            }
        }

        // åˆå§‹åŒ–æ‡‰ç”¨
        init();
        updateDropZone();
        loadSettings(); // è‡ªå‹•è¼‰å…¥è¨­å®š
    </script>
</body>
</html> 